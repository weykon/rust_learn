
https://blog.51cto.com/u_13127751/5267347


# 指针命题

## 智能指针的种类
标准库中的智能指针有如下几种。

Box<T>：它提供了最简单的堆资源分配方式。Box类型拥有其中的值，并且可用于保存结构体中的值，或者从函数返回它们。
Rc<T>：它用于引用计数。每当获取新引用时，计数器会执行递增操作，并在用户释放引用时对计数器执行递减操作。当计数器的值为零时，该值将被移除。
Arc<T>：它用于原子引用计数。这与之前的类型类似，但具有原子性以保证多线程的安全性。
Cell<T>：它为我们提供实现了Copy特征的类型的内部可变性。换句话说，我们有可能获得多个可变引用。
RefCell<T>：它为我们提供了类型的内部可变性，并且不需要实现Copy特征。它用于运行时的锁定以确保安全性。

Rc<T>：这主要用于单线程环境。
Arc<T>：这主要用于多线程环境。

Rc内部会保留两种引用：强引用（Rc<T>）和弱引用（Weak<T>）。二者都会维护每种类型的引用数量的计数，但是仅在强引用计数值为零时，才会释放该值。这样做的目的是数据结构的实现可能需要多次指向同一事物。例如，树的实现可能包含若干子节点和其父节点的引用，但是为每个引用递增引用计数器可能会导致循环引用

Rc 的强引用使用不当，可能构成引用循环（就是一个圆的指向图）

使用弱引用打破引用循环。


## Box 
```rs
struct Node {
    data: u32,
    next: Option<Node>
}

fn main() {
    let a = Node { data: 33, next: None };
}
```
我们不能这样定义Node类型，因为next有一个引用自身的类型。
```
struct Node {
    data: u32,
    next: Some(Node {
              data: u32,
              next: Node {
                        data: u32,
                        next: ...
                    }
          })
}
