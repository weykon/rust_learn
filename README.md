## 关于所有权这个内容

实则是整个rust当中最为重要和基础和关键的部分，
我就因为这个没特别明白，也就会出现由所有权问题导致的各种小问题，
而这些小问题的频繁出现，都是一些基础性的知识和概念
比如：转移过程中的借用复用，作用域的掌控，闭包（匿名）函数的使用

我是从书中重新去读，吸收新知识，才能解决心中疑惑。
有时候光靠面向问题的实践还是不够的。

rust语句分了`声明语句`和`表达式语句`， 这里突出的`语句`.
然后`表达式`当中，是我们目前话题的缘起。

`表达式`有：位置表达式，值表达式。其实这里我不建议记中文，因为它丢了意思。

Place Expression: 位置表达式，就是我们常用 `let * = *` 的等号的左侧。
这里明显有着一个place`放东西`的意思。

那么所有权跟这个有什么关系呢？ 
左边用于放东西的，那就像一个柜子，等式右边是柜子的东西。
我们平时把左侧的东西写出来，例如
```
let a = 1;
println!("{}",a);
```
这里的a是作为一个柜子就会搬到了println这里去`放着`（借用哈）

那么从这种场景去想象rust的所有表达式，都很容易的保持一个正确的逻辑去理解和写代码。

## 所有权和借用和&

然后，他们会到了一个新的境地，在我的理解，所有权不是必须每次使用都要转移的。
虽然我还不知道转移所有权的操作长什么样子，

使用&来借用，`&`就叫做借用操作符，我还常常认为那不过是一种引用的概念
比如
```rust
let a = [1,2,3];
let b = &a; 
```
这里是用的&是使用借用操作符&取得a的内存地址，赋值给b。
这里隐藏一个大彩蛋，右侧的&a已经不是我们之前的值表达式了，而是一个位置上下文。(Place Context)

然后&这个操作的出来的东西我们可以有一个新的类型名字，叫做`引用`。

