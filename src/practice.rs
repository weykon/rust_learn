struct Object {
    num: u8,
}

pub fn 拓展一下() {
    // 当传递的是一个对象的时候
    let obj = Object { num: 55 };

    read_num_in_obj(&obj.num);

}

fn read_num_in_obj(num: &u8) {
    println!("num : {}", num);
}
// 声明引用和使用 Box 有一些显著的区别：
// 动态内存分配：引用不会动态分配内存，它仅引用现有的内存。相反，Box 动态分配内存，因此其大小在运行时可以更改。
// 生存周期：引用必须指向有效的内存，它的生存周期必须超过引用的生存周期。相反，Box 在堆上分配内存，并且可以独立于引用的生存周期存在。
// 类型：引用的类型是原始类型的引用，例如 &i32。相反，Box 的类型是智能指针，其中包含一个指向堆上分配的对象的指针。
// 访问元素：访问引用中的元素不需要解引用，因为它已经是对原始数据的引用。相反，访问 Box 中的元素需要解引用，因为它包含一个指向堆上分配的对象的指针。
// 因此，如果您需要指向现有内存的引用，并且生存周期已经确定，则使用引用是一个不错的选择。但是，如果您需要动态分配内存，并且生存周期不确定，则使用 Box 可能是更好的选择。
